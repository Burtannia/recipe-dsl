\documentclass[11pt]{article}

\usepackage[hyphens]{url}

\usepackage{hyperref}
\hypersetup
{
    breaklinks = true,
    allcolors = black,
    linktoc = all
}

\usepackage{graphicx}

\usepackage{multicol}
\setlength{\columnseprule}{0.4pt}

\usepackage{listings}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\rhead{James Burton}
\lhead{ID: 4251529}
\fancyfoot[C]{\thepage}

\usepackage{titling}
\title
{ 
    G53IDS - Interim Report \\
    \hfill \break
    \large Embedded Domain Specific Language for \\
    Describing Recipes in Haskell
}

\setlength{\droptitle}{-10em}

\author{James Burton - 4251529 - psyjb6}

\begin{document}
    \maketitle
    \newpage

    \tableofcontents
    \newpage

    \section{Introduction}
    Consider the following recipe to make a cup of tea:

    \begin{tt}
    \begin{lstlisting}
    - Boil some water
    - Pour over a teabag
    - Wait for 3 minutes
    - Remove the teabag
    - Add milk (optional)
    \end{lstlisting}
    \end{tt}

    This is a very simple but useful recipe that many people
    will perform, in some cases, many times a day over their lives.
    What we can realise by looking at this recipe is that it actually
    consists of many smaller recipes, such as boiling water and
    combining tea with milk, performed in a certain order. This
    raises the question, to what extent does the order matter and
    to what extent can we rearrange things in order to make the recipe
    more efficient? No doubt you have done this, maybe subconsciously,
    while cooking at home. Furthermore which steps can be done
    concurrently in the event that multiple people are cooking e.g.
    in a professional kitchen with a full brigade? \\

    Perhaps closer to computer science, we could also ask, how could
    we instruct a robot to do this? After doing some research on
    robotic chefs it appears that not a huge number exist.
    There is one home cooking robot \cite{robot} which uses motion
    capture in order to learn recipes. In my opinion this is rather
    restrictive. It presumes that the human performs the recipe in
    the optimal manner and it would be very difficult to model
    a brigade system in this way. In reality there is a limited set
    of fundamental actions that one becomes able to perform when
    learning to cook. Recipes can then be performed using a sequence
    of these actions. Representing recipes like this would allow us
    to take a robot programmed to perform each of the fundamental
    actions and tell it how to cook literally anything. \\

    So we've established that if we can structure recipes in a more
    formal way then we will have a great amount of freedom in terms
    of how we process them whether it be optimisation for a human
    chef or full on automation. My contributions / planned contributions
    to this are the following:

    \begin{itemize}
        \item Define a set of combinators as an EDSL in Haskell and show that
        they can be used to describe a wide variety of recipes (Section 2).

        \item The combinators describe a recipe but we then need to know
        how to execute a recipe as a sequence of the fundamental actions
        mentioned above. Fortunately, as described above, recipes are just
        a combination of simpler recipes meaning that we can recursively
        define the actions necessary to perform complex recipes as long
        as we have manually defined which action are required for each
        combinator (Section 3).

        \item We now have a way to describe recipes and a way to show the
        sequence of actions to complete a recipe but now we need to apply
        them to something. Using the operational semantics of recipes
        we can optimise and schedule recipes for a given kitchen system.
        We can then express this in several ways including printing steps,
        drawing the cooking process as a graph or simulating the recipe
        within the given kitchen setup (Section 4).

        \item It may also be useful to provide an intermediate language
        between informal English and our combinators, some sort of markup
        language, that can then be parsed in.
    \end{itemize}

    \section{Describing Recipes}
    In this section I shall outline the EDSL for describing recipes.
    The EDSL is implemented in the functional programming language
    called Haskell. Haskell has been used for many EDSLs in the past \cite{hudak}.
    Michael Snoyman, creator of Yesod (a Haskell Web Framework), stated
    many advantages of using Haskell for EDSLs among which were that
    the type system helps catch mistakes and Haskell allows us to
    overload almost any syntax \cite{snoyman}.

    \subsection{A Cup of Tea}
    Consider our cup of tea example from earlier. We can start by
    defining all of our ingredients:

    \begin{tt}
    \begin{lstlisting}
        milk, teabag, water :: Recipe
        milk = Ingredient "milk"
        teabag = Ingredient "teabag"
        water = Ingredient "water"
    \end{lstlisting}
    \end{tt}

    The next step is to start describing what we want to transform
    those ingredients into for example:

    \begin{tt}
    \begin{lstlisting}
        boilingWater, blackTea :: Recipe
        boilingWater = heat 100 water
        blackTea = (teabag >< boilingWater) >>> Wait 5
    \end{lstlisting}
    \end{tt}

    We've introduced three things here. \texttt{heat} is simply
    a function meaning heat the given recipe to the given temperature.
    \texttt{><} is our combine operator and simply means mix the
    given recipes together. Finally \texttt{>>>} is our sequencing
    operator meaning do the first recipe then the second. The types
    for these are as follows: 
    
    \begin{tt}
    \begin{lstlisting}
        heat :: Temperature -> Recipe -> Recipe
        (><) :: Recipe -> Recipe -> Recipe
        (>>>) :: Recipe -> Recipe -> Recipe
    \end{lstlisting}
    \end{tt}

    We can now use the above to define our cup of tea recipe as follows:

    \begin{tt}
    \begin{lstlisting}
        cupOfTea :: Recipe
        cupOfTea = blackTea >< milk
    \end{lstlisting}
    \end{tt}

    Now you may notice that we haven't mentioned preparation of ingredients
    for example measuring how much of them to use. While experimenting with
    the basic representation of a recipe and the different ways to interpret
    it we thought it would be beneficial to keep the combinators as simple
    and abstract as possible. This means that, for now, we will be describing
    recipes "cooking show" style where we presume everything is conveniently
    measured and prepared in a bowl next to the chef.

    \subsection{Currying - But Not What You Think}
    In this section I shall introduce the full set of combinators we are
    currently working with and proceed to build up a more complex recipe.

    \begin{figure}
        \centering
            \begin{multicols}{2}
                \texttt{ingredient :: String -> Recipe}
                The recipe \texttt{(ingredient s)} simply represents an ingredient
                with the name s.

                \texttt{heat :: Temperature -> Recipe -> Recipe}
                \texttt{heat t r} means to heat r to the temperature t. 

                \texttt{wait :: Time -> Recipe}
                \texttt{wait t} simply means do nothing for t amount of time.
                The decision to for \texttt{wait} to not include a recipe as
                an argument was very deliberate (Section 3.3).

                \texttt{(><) :: Recipe -> Recipe -> Recipe}
                The recipe \texttt{r1 >< r2} is the combination of r1 and r2.
                The details of the method you use to combine the recipes are
                not yet captured.

                \texttt{(>>>) :: Recipe -> Recipe -> Recipe}
                \texttt{r1 >>> r2} represents the sequence of r1 and r2 i.e.
                perform recipe r1 followed by recipe r2.
            \end{multicols}
        \caption{Combinators for defining recipes}
    \end{figure}

    \subsection{Conditionals}

    Mention wait combination.

    \subsection{Moving Forward}
    At the time of writing this interim report, the combinators we
    have are decent but not perfect. There are several crucial pieces
    of information not captured such as measurements and, as mentioned
    above, conditionals and optional recipes are not yet implemented.

    Now that we have a more detailed idea of the components of the project,
    we can move towards implementing them. That will naturally provide
    an opportunity to scrutinise the set of combinators we are working
    with by analysing any issues we run into.

    \section{Executing a Recipe}
    \begin{figure}[h]
        \centering
            \includegraphics[width=\textwidth,keepaspectratio]{actions_time.png}
        \caption{Number of possible actions over time.}
    \end{figure}

    \begin{figure}[h]
        \centering
            \includegraphics[width=\textwidth,keepaspectratio]{recipe_flow.png}
        \caption{Components of the recipe system.}
    \end{figure}

    
    \section{Implementation}

    \section{Progress}
    This project shall use the scrum development methodology. With the
    gaps between supervisor meetings acting as the sprints. The scrum
    methodology seems most appropriate for this project as it is naturally
    very flexibly and doesn't require a huge amount of detailed planning
    in advance. This suits the research nature of the project as it is
    impossible to precisely state what will be done and when. Each sprint
    offers an opporuntity to re-prioritise and alter tasks based upon
    the progress and findings of the previous sprint.
    \subsection{Project Management}
    \subsection{Contributions and Reflections}

    \section{Related Work}

    \newpage
    \begin{thebibliography}{0}

        \bibitem{robot}
        The Guardian. 2015. \textit{Future of food: how we cook}.
        \url{https://www.theguardian.com/technology/2015/sep/13/future-of-food-how-we-cook}

        \bibitem{hudak}
        Paul Hudak. Domain Specific Languages. Department of Computer
        Science, Yale University, December 15, 1997.

        \bibitem{snoyman}
        Michael Snoynman. O'Reilly Webcast: Designing Domain Specific
        Languages with Haskell. January 4, 2013.
        \url{https://www.youtube.com/watch?v=8k_SU1t50M8}

        \bibitem{contracts}
        Simon Peyton Jones, Microsoft Research, Cambridge.
        Jean-Marc Eber, LexiFi Technologies, Paris. Julian Seward,
        University of Glasgow. Composing contracts: an adventure in
        financial engineering. August 17, 2000.


    \end{thebibliography}   
     
\end{document}