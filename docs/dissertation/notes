Conditionals allow us to mix until "mixed". The concrete implementation can then be used
to link this to a signal from a camera in the case of a robot (or some other decision
logic).

Remove Combinator

-----------------------
Deriving Equality:

Multiple representations, can hash recipes to a value.
Can look at topological sorts.
At some point we need to specify which combinators
are commutative. Combine a b == Combine b a
really depends on how you combine. Mix is
commutative whereas spread isn't.

-----------------------

-----------------------
Measuring:

Default measurements on ingredients or have measurement in ingredient constructor?

"To taste" measurement.
-----------------------

-----------------------
Do For vs Do then Wait for
Heat to / for vs Heat at (maybe both)

Do for and heat to / for -> wrap recipe in conditional
Heat combinator becomes HeatAt
Wait takes a recipe
Sequencing is removed

HeatAt then needs to be able to take void for temp

Unless we have a generic Heat combinator
Heat "Nothing" with a Condition of the preheat temp
then combine that with the recipe we want to heatAt
that temp.

It may then seem intuitive to model Wait as a combination
of a void recipe wrapped in a time condition and the
recipe we want to wait after except that there is
nothing that would prevent the recipe from being executed
after the wait rather than before since dependency is
indicated by the parent node being dependent on its child nodes.

Maybe we don't need a special combinator. Ovens have
a large range of heat settings, hobs have fewer however,
we could consider a kettle being ON to be a single heat setting.

In which case we can add "on" or something similar as a 
valid temperature. But we might not even need to.
A toaster cooks toast when it's "on" but the temperature
could still be measured in other ways. It turns out it is
over 600C. You could toast bread in a pan at a lower
temperature but it would take longer.
-----------------------

-----------------------
Wrap in transaction

Issue with wrap in transaction:
forces everything below in tree to become wrapped,
could add number of previous steps to wrap (not particularly nice).

Could only wrap immediate children, could chain transactions

Transaction means perform r immediately after direct dependencies
are completed.

For combine, might only care about performing immediately after
one of the dependencies. Adding this could be messy,
having a more basic transaction type only results in a slight
loss of flexibility in scheduling.
-----------------------