Two events:
 - begin
 - until

Both types of conditionals. Presumed that previous steps of the recipe ensure that the
conditions to start a recipe are met e.g. leave to marinate for 2 hours.

Conditionals allow us to mix until "mixed". The concrete implementation can then be used
to link this to a signal from a camera in the case of a robot (or some other decision
logic).

- Station System
- Scheduling
- Derive Equality (topological sorting)
- Readd Mesaure
- Cost of recipe
- Until "Done" condition which evaluates to external source 
- Have considered uses for production of food, what about development of food (mapping properties etc.)
- What effect to ingredients have on a recipe, seasoning, flavour profile, thickening etc.
- Transformations e.g. whisk egg or blend fruit, ways to chop etc.
- There is a lstlisting preset on the literate haskell page

- once we have the "meal components" / balance system
- provide list of ingredients with cost
    - what they add to a meal
    - how much you need
    - what you do with them e.g. heatAt x
- along with all the components needed in a meal
- then create meals minimising the cost using LP
- presume portions fit nicely into amount we can buy
- can also choose a cuisine and pick ingredients from that cuisine to improve dish

-----------------------
Scheduling:

Linear Programming

-----------------------

-----------------------
QuickSpec:

-----------------------

-----------------------
Deriving Equality:

Multiple representations, can hash recipes to a value.
Can look at topological sorts.
At some point we need to specify which combinators
are commutative. Combine a b == Combine b a
really depends on how you combine. Mix is
commutative whereas spread isn't.

Start off with everything being equal
or nothing being equal.

Better to have a stricter equality than a
weaker one.

Constraints:
- Ingredients must match.
- Condense chained waits etc.

-----------------------

-----------------------
Temporary / Removeable Recipes e.g. Bay Leaf

Mark recipe as removeable.
Remove later.
Remove presumes a corresponding removeable was already added.
-----------------------

-----------------------
Scheduling / Actions:

Can allocate parts of recipe to stations then translate into appropriate actions.
This creates a schedule where each station has its set of actions running in parallel.
Need to schedule movement between stations.

- Interactions between stations e.g. stirring while in pan.
-----------------------

-----------------------
Measuring:

Default measurements on ingredients or have measurement in ingredient constructor?

"To taste" measurement.
-----------------------

-----------------------
Do For vs Do then Wait for
Heat to / for vs Heat at (maybe both)

Do for and heat to / for -> wrap recipe in conditional
Heat combinator becomes HeatAt
Wait takes a recipe
Sequencing is removed

HeatAt then needs to be able to take void for temp

Unless we have a generic Heat combinator
Heat "Nothing" with a Condition of the preheat temp
then combine that with the recipe we want to heatAt
that temp.

It may then seem intuitive to model Wait as a combination
of a void recipe wrapped in a time condition and the
recipe we want to wait after except that there is
nothing that would prevent the recipe from being executed
after the wait rather than before since dependency is
indicated by the parent node being dependent on its child nodes.

Maybe we don't need a special combinator. Ovens have
a large range of heat settings, hobs have fewer however,
we could consider a kettle being ON to be a single heat setting.

In which case we can add "on" or something similar as a 
valid temperature. But we might not even need to.
A toaster cooks toast when it's "on" but the temperature
could still be measured in other ways. It turns out it is
over 600C. You could toast bread in a pan at a lower
temperature but it would take longer.
-----------------------

-----------------------
Wrap in transaction

Issue with wrap in transaction:
forces everything below in tree to become wrapped,
could add number of previous steps to wrap (not particularly nice).

Could only wrap immediate children, could chain transactions

Transaction means perform r immediately after direct dependencies
are completed.

For combine, might only care about performing immediately after
one of the dependencies. Adding this could be messy,
having a more basic transaction type only results in a slight
loss of flexibility in scheduling.
-----------------------